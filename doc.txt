ECE467 - Lab 2
Chinmayee Gidwani
Kamran Ramji

Design decisions:
	Variable shadowing - for simplicity, variable shadowing was not allowed. This allows our type checker to maintain a simple symbol table, inherited from the parent scope, which maps names to types. If we encounter a declaration for which there is already a corresponding entry in the symbol table, this is automatically an error (ie there is no need to check if the variable was declared in this or the parent scope).
	Type matching for binary expressions and assignments - assignments are treated like any other binary operation in this respect. We simply compare the two sides of the operation, and if the types do not match, this is an error
	Ternary expressions - this is not explicitly required in the lab document, but excluding this case makes it difficult to check required cases, i.e. if the result of a ternary expression is used in a binary expression, then the type of the result of the ternary expression must be well-defined. Therefore, we check that the operands of the ternary expression are of the same type, in addition to checking that the predicate is of type bool
	Return statements - these are checked in two stages. The first round checks for "type compatibility", that is, any return statements inside a function should match the return type of that function. This is done using a two-pronged approach: within any nested blocks within functions, we check to make sure that all return statements are of the same type (ie if you return a float, and later on, a bool, one of those is guaranteed to be incorrect, and so we already know we have an error); then, outside of the recursion, we check that each statement inside the block only contain return statements matching the return type of the function we are currently in. The second round checks to make sure that we have at least one return statement in the control flow, that is, we have a return statement somewhere in our function that is not nested (unless our function has return type void).
	Constant propagation - this was implemented using dynamic_cast. Dynamic casting allows us to check if the arguments of a given relational, unary or binary operation are, in fact, ints, floats or bools, because we can cast to those types, and check if the result is a nullptr. If it is not, then our cast was successful, and we can proceed to propagate the constants.


